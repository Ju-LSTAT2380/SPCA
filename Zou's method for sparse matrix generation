##### Zou's data generation #####
# Les PCs récupéré peuvent ne pas être dans l'ordre !!!
simX = function(seed = 20231002,
                n = 1000,
                mu = 0,
                sigma = c(290,300),
                subX = 4,# Number of daughter var (one number of vector of value of length(sigma))
                subC = floor(length(sigma)/2),# Number of correleted var from daughter var
                subCorr = 2,# Number of correlated variables generated per correlation
                num.corr = 2,# Number of X's variables per correleted variables
                reuse = FALSE,# Set replace = T/F in the sampling for correlated variables
                corr = FALSE,# Adding correlation?
                mix = FALSE,# Mixing variables ?
                minmax = c(0.05,.95)) {# Range of value for correlation coefficient
  set.seed(seed)
  # creating matrix for ind variables
  v.ind = matrix(nrow = n,ncol = length(sigma),byrow = TRUE)
  ## generating true var
  v.ind[,1:length(sigma)] = sapply(1:length(sigma),function(i) rnorm(n,sd = sigma[i]))
  # get number of X ind variables
  if (length(subX) == length(sigma)) {
    v.ind_ncol = sum(subX)
  } else if (length(subX) == 1) {
    v.ind_ncol = length(sigma)*subX
  } else stop()
  # making vector of V for X
  vec = sort(rep(1:length(sigma),subX))
  ##### Mixing variables ?
  if (mix == TRUE) {
    vec = sample(vec,v.ind_ncol)
  } else {
    vec = sort(vec,decreasing = TRUE)
  }
  # create matrix for X
  X = as.data.frame(sapply(1:v.ind_ncol,function(i) rnorm(n) + v.ind[,vec[i]]))
  # If correlated variables are asked
  if (corr == TRUE) {
    # Make coeff
    minmax = sort(minmax)
    samp = sample(rep(1:subC,num.corr,replace = reuse))
    coeff = sapply(1:subC,function(j) ifelse(samp == j,sample(c(-1,1),num.corr,replace = TRUE)*runif(num.corr,min = minmax[1],max = minmax[2]),0))
    # Making matrix of correlated variables
    if ((floor(length(sigma)/2) - length(sigma)/2) == 0) v.corr = v.ind %*% coeff + rnorm(n*subC)
    if ((floor(length(sigma)/2) - length(sigma)/2) != 0) v.corr = v.ind[,1:(length(sigma)-1)] %*% coeff + rnorm(n*subC)
    # Combining the two matrices
    vec.corr = rep(1:ncol(v.corr),subCorr)
    v.corr_ncol = ncol(v.corr)*subCorr
    ##### Mixing variables ?
    if (mix == TRUE) {
      vec.corr = sample(vec.corr,v.corr_ncol)
    } else {
      vec.corr = sort(vec.corr,decreasing = TRUE)
    }
    X.corr = as.data.frame(sapply(1:v.corr_ncol,function(i) rnorm(n) + v.corr[,vec.corr[i]]))
    X = cbind(X,X.corr)
  }
  colnames(X) = paste0("X",1:ncol(X))
  # Saving vector of PCs
  matvec = sapply(1:length(sigma),function(j) ifelse(vec == j,vec,0))
  matvec = ifelse(matvec !=0,which(vec !=0),0)
  if (corr == TRUE) matvec = rbind(matvec,matrix(rep(rep(0,length(sigma)),subC*subCorr),ncol = length(sigma)))
  colnames(matvec) = paste0("PC",1:length(sigma))
  matvec = ifelse(matvec != 0,1,0)
  matvec / norm(matvec,"2")
  # Returning values and matrices
  if (corr == TRUE) {
    return(list(variables = v.ind,# True Variable => PCs
                correlated = v.corr,# Matrix of correlated variables
                R = X,# True Matrix X
                Gram = cor(X),# Gram matrix
                X = 1/sqrt(n)*scale(X),# Scaled version of X
                mat.sparse = matvec,# Sparse matrix of PCs one should obtain from X, ideally
                coefficients = coeff))# Matrix of coefficient (for correlated var)
  } else {
    return(list(variables = v.ind,# True Variable => PCs
                R = X,# True Matrix X
                Gram = cor(X# Gram matrix
                X = 1/sqrt(n)*scale(X),# Scaled version of X
                mat.sparse = matvec))# Sparse matrix of PCs one should obtain from X, ideally
  }
}
